diff --git a/next.config.ts b/next.config.ts
index 38b004f8574e571a6b38adeda02b7b30f4a90cb0..60a7ce7d71b1841351dc69c38fd58c28290b1690 100644
--- a/next.config.ts
+++ b/next.config.ts
@@ -1,43 +1,75 @@
 import type { NextConfig } from "next";
+import createNextPWA from "next-pwa";
 
-const nextConfig: NextConfig = {
+const isProd = process.env.NODE_ENV === "production";
+
+const runtimeCaching = [
+  {
+    urlPattern: /^https:\/\/fonts\.(gstatic|googleapis)\.com\/.*/i,
+    handler: "CacheFirst",
+    options: {
+      cacheName: "google-fonts",
+      expiration: { maxEntries: 20, maxAgeSeconds: 60 * 60 * 24 * 30 },
+    },
+  },
+  {
+    urlPattern: /^https?:\/\/.*/i,
+    handler: "NetworkFirst",
+    options: {
+      cacheName: "offline-cache",
+      networkTimeoutSeconds: 10,
+      expiration: { maxEntries: 150, maxAgeSeconds: 60 * 60 * 24 * 7 },
+    },
+  },
+];
+
+const withPWA = createNextPWA({
+  dest: "public",
+  disable: !isProd,
+  register: true,
+  skipWaiting: true,
+  runtimeCaching,
+  buildExcludes: [/middleware-manifest.json$/],
+});
+
+const nextConfig: NextConfig = withPWA({
   reactStrictMode: true,
   experimental: {
     serverActions: {
       allowedOrigins: ["*"],
     },
   },
   async headers() {
     return [
       {
         source: "/manifest.json",
         headers: [
           {
             key: "Cache-Control",
             value: "public, max-age=31536000, immutable",
           },
         ],
       },
       {
         source: "/icons/:path*",
         headers: [
           {
             key: "Cache-Control",
             value: "public, max-age=31536000, immutable",
           },
         ],
       },
       {
         source: "/_next/static/:path*",
         headers: [
           {
             key: "Cache-Control",
             value: "public, max-age=31536000, immutable",
           },
         ],
       },
     ];
   },
-};
+});
 
 export default nextConfig;
diff --git a/package.json b/package.json
index 48a5afd04d9648397258e920912ca15cb5512674..b29bc31754943027ed99e9f37a9fd21fa18d89e6 100644
--- a/package.json
+++ b/package.json
@@ -1,41 +1,44 @@
 {
   "name": "health_app",
   "version": "0.1.0",
   "private": true,
   "scripts": {
     "dev": "next dev",
     "build": "next build",
     "start": "next start",
     "lint": "next lint",
+    "test:e2e": "playwright test",
     "usda:download": "node scripts/download_usda.js",
     "usda:flatten": "node scripts/flatten_data.js",
     "usda:embed": "node scripts/embed_and_upload.js"
   },
   "dependencies": {
     "adm-zip": "^0.5.12",
     "@google/generative-ai": "^0.11.4",
     "@upstash/ratelimit": "^1.1.4",
     "@upstash/redis": "^1.32.0",
     "@supabase/auth-helpers-nextjs": "^0.10.0",
     "@supabase/ssr": "^0.4.0",
     "@supabase/supabase-js": "^2.48.0",
     "@xenova/transformers": "^2.17.2",
     "recharts": "^2.12.7",
     "csv-parse": "^5.5.6",
     "react-hot-toast": "^2.4.1",
     "next": "^15.0.3",
     "react": "^18.3.1",
-    "react-dom": "^18.3.1"
+    "react-dom": "^18.3.1",
+    "next-pwa": "^5.6.0"
   },
   "devDependencies": {
     "@types/node": "^22.9.4",
     "@types/react": "^18.3.12",
     "@types/react-dom": "^18.3.1",
+    "@playwright/test": "^1.48.2",
     "autoprefixer": "^10.4.20",
     "eslint": "^9.14.0",
     "eslint-config-next": "^15.0.3",
     "postcss": "^8.4.47",
     "tailwindcss": "^3.4.14",
     "typescript": "^5.6.3"
   }
 }
diff --git a/playwright.config.ts b/playwright.config.ts
new file mode 100644
index 0000000000000000000000000000000000000000..afc4612dcd2c30c2629f648a7b253d9b511247a1
--- /dev/null
+++ b/playwright.config.ts
@@ -0,0 +1,20 @@
+import { defineConfig, devices } from "@playwright/test";
+
+export default defineConfig({
+  testDir: "./tests",
+  timeout: 60000,
+  expect: {
+    timeout: 10000,
+  },
+  use: {
+    baseURL: process.env.PLAYWRIGHT_BASE_URL || "http://localhost:3000",
+    headless: true,
+    trace: "retain-on-failure",
+  },
+  projects: [
+    {
+      name: "chromium",
+      use: { ...devices["Desktop Chrome"] },
+    },
+  ],
+});
diff --git a/scripts/cleanup_storage.js b/scripts/cleanup_storage.js
new file mode 100644
index 0000000000000000000000000000000000000000..9b7f9a1d0cbf5cba1bcc177631f45565b1abba0a
--- /dev/null
+++ b/scripts/cleanup_storage.js
@@ -0,0 +1,83 @@
+// Delete storage objects older than 30 days or orphaned from food_logs.image_path.
+// Run with: node scripts/cleanup_storage.js
+// Requires SUPABASE_URL, SUPABASE_SERVICE_ROLE_KEY, and optionally SUPABASE_STORAGE_BUCKET.
+// eslint-disable-next-line @typescript-eslint/no-var-requires
+const { createClient } = require("@supabase/supabase-js");
+
+const url = process.env.SUPABASE_URL || process.env.NEXT_PUBLIC_SUPABASE_URL;
+const serviceKey = process.env.SUPABASE_SERVICE_ROLE_KEY;
+const bucket = process.env.SUPABASE_STORAGE_BUCKET || process.env.NEXT_PUBLIC_SUPABASE_STORAGE_BUCKET || "user-images";
+
+if (!url || !serviceKey) {
+  console.error("Missing SUPABASE_URL or SUPABASE_SERVICE_ROLE_KEY");
+  process.exit(1);
+}
+
+const supabase = createClient(url, serviceKey);
+const cutoff = new Date();
+cutoff.setDate(cutoff.getDate() - 30);
+
+async function listAll(prefix = "") {
+  const files = [];
+  let from = 0;
+  const size = 100;
+
+  // eslint-disable-next-line no-constant-condition
+  while (true) {
+    const { data, error } = await supabase.storage.from(bucket).list(prefix, {
+      limit: size,
+      offset: from,
+    });
+    if (error) {
+      throw error;
+    }
+    if (!data?.length) break;
+    for (const entry of data) {
+      if (entry.name === ".emptyFolderPlaceholder") continue;
+      if (entry.metadata?.mimetype === "folder") {
+        const nested = await listAll(`${prefix}${entry.name}/`);
+        files.push(...nested);
+      } else {
+        files.push({ ...entry, path: `${prefix}${entry.name}` });
+      }
+    }
+    if (data.length < size) break;
+    from += size;
+  }
+
+  return files;
+}
+
+async function main() {
+  const { data: logs, error: logsError } = await supabase
+    .from("food_logs")
+    .select("image_path")
+    .not("image_path", "is", null);
+
+  if (logsError) throw logsError;
+
+  const referenced = new Set((logs ?? []).map((row) => row.image_path));
+  const files = await listAll();
+
+  const stale = files.filter((file) => {
+    const updated = new Date(file.updated_at ?? file.created_at ?? file.last_accessed_at ?? new Date(0));
+    const isOld = updated < cutoff;
+    const orphaned = !referenced.has(file.path);
+    return isOld || orphaned;
+  });
+
+  if (!stale.length) {
+    console.log("No stale images to delete.");
+    return;
+  }
+
+  const { error } = await supabase.storage.from(bucket).remove(stale.map((file) => file.path));
+  if (error) throw error;
+
+  console.log(`Deleted ${stale.length} stale images from ${bucket}`);
+}
+
+main().catch((err) => {
+  console.error("Cleanup failed", err);
+  process.exit(1);
+});
diff --git a/src/app/WeightLogger.tsx b/src/app/WeightLogger.tsx
new file mode 100644
index 0000000000000000000000000000000000000000..9e10f06038cee46f09b6eb67e940b00846a5f4c7
--- /dev/null
+++ b/src/app/WeightLogger.tsx
@@ -0,0 +1,77 @@
+"use client";
+
+import { useState } from "react";
+import toast from "react-hot-toast";
+import { logWeight } from "./actions";
+
+export default function WeightLogger({
+  defaultWeight,
+}: {
+  defaultWeight?: number | null;
+}) {
+  const [weight, setWeight] = useState<number>(defaultWeight ?? 70);
+  const [date, setDate] = useState<string>(new Date().toISOString().slice(0, 10));
+  const [loading, setLoading] = useState(false);
+
+  const submit = async () => {
+    if (!weight || weight <= 0) {
+      toast.error("Enter a valid weight in kg");
+      return;
+    }
+
+    setLoading(true);
+    try {
+      await logWeight(weight, new Date(date).toISOString());
+      toast.success("Weight saved");
+    } catch (err) {
+      console.error(err);
+      toast.error(err instanceof Error ? err.message : "Unable to save weight");
+    } finally {
+      setLoading(false);
+    }
+  };
+
+  return (
+    <div className="card space-y-3">
+      <div className="flex items-center justify-between">
+        <div>
+          <p className="text-sm uppercase tracking-wide text-emerald-200">
+            Body weight
+          </p>
+          <h2 className="text-xl font-semibold text-white">Log today&apos;s weight</h2>
+        </div>
+        <span className="pill bg-white/10 text-white/70">History feeds charts</span>
+      </div>
+      <div className="flex flex-wrap items-center gap-3 text-sm text-white/80">
+        <label className="space-y-1">
+          <span className="block text-xs uppercase tracking-wide text-white/60">
+            Weight (kg)
+          </span>
+          <input
+            className="w-32 rounded-lg border border-white/10 bg-white/5 px-3 py-2 text-white focus:border-emerald-400 focus:outline-none"
+            type="number"
+            min={1}
+            step="0.1"
+            value={weight}
+            onChange={(e) => setWeight(Number(e.target.value))}
+          />
+        </label>
+        <label className="space-y-1">
+          <span className="block text-xs uppercase tracking-wide text-white/60">
+            Date
+          </span>
+          <input
+            className="rounded-lg border border-white/10 bg-white/5 px-3 py-2 text-white focus:border-emerald-400 focus:outline-none"
+            type="date"
+            value={date}
+            max={new Date().toISOString().slice(0, 10)}
+            onChange={(e) => setDate(e.target.value)}
+          />
+        </label>
+        <button className="btn" disabled={loading} onClick={submit} type="button">
+          {loading ? "Saving..." : "Save weight"}
+        </button>
+      </div>
+    </div>
+  );
+}
diff --git a/src/app/actions.ts b/src/app/actions.ts
index 69a2f2a30c344d78c45c569a6de903c474017cf2..9621a0f8b84e9b090230a2db4379cd01e198cb1d 100644
--- a/src/app/actions.ts
+++ b/src/app/actions.ts
@@ -233,25 +233,177 @@ export async function updateFoodLog(id: string, changes: Partial<{ food_name: st
 }
 
 export async function deleteFoodLog(id: string) {
   const supabase = createSupabaseServerClient();
   const {
     data: { session },
   } = await supabase.auth.getSession();
 
   if (!session) {
     throw new Error("You must be signed in to delete entries.");
   }
 
   const { error } = await supabase
     .from("food_logs")
     .delete()
     .eq("id", id)
     .eq("user_id", session.user.id);
 
   if (error) {
     throw error;
   }
 
   revalidatePath("/");
   revalidatePath("/stats");
 }
+
+export async function logWeight(weightKg: number, loggedAt?: string) {
+  const supabase = createSupabaseServerClient();
+  const {
+    data: { session },
+  } = await supabase.auth.getSession();
+
+  if (!session) {
+    throw new Error("You must be signed in to save weight.");
+  }
+
+  const { error } = await supabase.from("weight_logs").insert({
+    user_id: session.user.id,
+    weight_kg: weightKg,
+    logged_at: loggedAt ?? new Date().toISOString(),
+  });
+
+  if (error) {
+    throw error;
+  }
+
+  revalidatePath("/stats");
+}
+
+export type MealTemplateItem = {
+  food_name: string;
+  weight_g: number;
+  calories: number | null;
+  protein: number | null;
+  carbs: number | null;
+  fat: number | null;
+};
+
+export async function saveMealTemplate(name: string, items: MealTemplateItem[]) {
+  const supabase = createSupabaseServerClient();
+  const {
+    data: { session },
+  } = await supabase.auth.getSession();
+
+  if (!session) {
+    throw new Error("You must be signed in to save templates.");
+  }
+
+  const { data, error } = await supabase
+    .from("meal_templates")
+    .insert({
+      user_id: session.user.id,
+      name,
+      items,
+    })
+    .select()
+    .single();
+
+  if (error) {
+    throw error;
+  }
+
+  return data;
+}
+
+export async function applyMealTemplate(templateId: string) {
+  const supabase = createSupabaseServerClient();
+  const {
+    data: { session },
+  } = await supabase.auth.getSession();
+
+  if (!session) {
+    throw new Error("You must be signed in to load templates.");
+  }
+
+  const { data: template, error: templateError } = await supabase
+    .from("meal_templates")
+    .select("items, name, user_id")
+    .eq("id", templateId)
+    .maybeSingle();
+
+  if (templateError) {
+    throw templateError;
+  }
+
+  if (!template || template.user_id !== session.user.id) {
+    throw new Error("Template not found.");
+  }
+
+  const now = new Date();
+  const payload =
+    (template.items as MealTemplateItem[] | null)?.map((item, index) => ({
+      user_id: session.user.id,
+      food_name: item.food_name,
+      weight_g: item.weight_g,
+      calories: item.calories,
+      protein: item.protein,
+      carbs: item.carbs,
+      fat: item.fat,
+      consumed_at: new Date(now.getTime() - index * 1000).toISOString(),
+    })) ?? [];
+
+  if (!payload.length) {
+    throw new Error("Template has no items to insert.");
+  }
+
+  const { data, error } = await supabase.from("food_logs").insert(payload).select();
+
+  if (error) {
+    throw error;
+  }
+
+  revalidatePath("/");
+  revalidatePath("/stats");
+  return data;
+}
+
+export async function getRecentFoods() {
+  const supabase = createSupabaseServerClient();
+  const {
+    data: { session },
+  } = await supabase.auth.getSession();
+
+  if (!session) {
+    throw new Error("You must be signed in to view recents.");
+  }
+
+  const { data, error } = await supabase
+    .from("food_logs")
+    .select("food_name, calories, protein, carbs, fat, weight_g, consumed_at")
+    .eq("user_id", session.user.id)
+    .order("consumed_at", { ascending: false })
+    .limit(40);
+
+  if (error) {
+    throw error;
+  }
+
+  const seen = new Set<string>();
+  const unique = [];
+  for (const row of data ?? []) {
+    const name = row.food_name.toLowerCase();
+    if (seen.has(name)) continue;
+    seen.add(name);
+    unique.push({
+      description: row.food_name,
+      kcal_100g: row.calories ?? null,
+      protein_100g: row.protein ?? null,
+      carbs_100g: row.carbs ?? null,
+      fat_100g: row.fat ?? null,
+      similarity: null,
+    });
+    if (unique.length >= 10) break;
+  }
+
+  return unique;
+}
diff --git a/src/app/home-client.tsx b/src/app/home-client.tsx
index bd6f2f2c295b09bb4b52fb86226813c05b8f94cf..b34800d8dc37c1cfd3915a5c7b7ff3b139664461 100644
--- a/src/app/home-client.tsx
+++ b/src/app/home-client.tsx
@@ -1,82 +1,107 @@
 "use client";
 
 import Image from "next/image";
 import { useRouter } from "next/navigation";
 import React, { useMemo, useState, useTransition } from "react";
 import toast from "react-hot-toast";
 import {
   deleteFoodLog,
   logFood,
   manualSearch,
+  applyMealTemplate,
+  getRecentFoods,
+  saveMealTemplate,
   signOutAction,
   updateFoodLog,
   upsertUserProfile,
+  type MealTemplateItem,
 } from "./actions";
 import { supabaseBrowser } from "@/lib/supabase";
 
 type MacroMatch = {
   description: string;
   kcal_100g: number | null;
   protein_100g: number | null;
   carbs_100g: number | null;
   fat_100g: number | null;
   similarity?: number | null;
 };
 
 type DraftLog = {
   food_name: string;
   quantity_estimate: string;
   search_term: string;
   match?: MacroMatch;
   weight: number;
 };
 
 type FoodLogRecord = {
   id: string;
   food_name: string;
   weight_g: number;
   calories: number | null;
   protein: number | null;
   carbs: number | null;
   fat: number | null;
   consumed_at: string;
   image_path?: string | null;
 };
 
 type UserProfile = {
   user_id: string;
   height: number | null;
   weight: number | null;
   age: number | null;
   activity_level: string | null;
   goal_type: string | null;
   macro_split: Record<string, unknown> | null;
   daily_calorie_target: number | null;
   daily_protein_target: number | null;
 } | null;
 
+type MealTemplate = {
+  id: string;
+  name: string;
+  items: MealTemplateItem[];
+};
+
+type PortionMemoryRow = {
+  food_name: string;
+  weight_g: number;
+  count: number;
+};
+
+type RecentFood = {
+  food_name: string;
+  calories: number | null;
+  protein: number | null;
+  carbs: number | null;
+  fat: number | null;
+  weight_g: number;
+};
+
 type ActivityLevel = "sedentary" | "light" | "moderate" | "active" | "very_active";
 type GoalType = "lose" | "maintain" | "gain";
 type ProfileFormState = {
   height: number;
   weight: number;
   age: number;
   activityLevel: ActivityLevel;
   goalType: GoalType;
   macroSplit: Record<string, number>;
 };
 
 function extractWeight(estimate: string) {
   const parsed = estimate.match(/(\d+(?:\.\d+)?)\s*g?/i);
   if (parsed?.[1]) return Number(parsed[1]);
   return 100;
 }
 
 function buildDateFromInput(value: string) {
   const [year, month, day] = value.split("-").map(Number);
   if (
     Number.isNaN(year) ||
     Number.isNaN(month) ||
     Number.isNaN(day) ||
     month < 1 ||
     month > 12 ||
@@ -105,50 +130,60 @@ function formatNumber(value: number | null | undefined, digits = 1) {
 function adjustedMacros(match: MacroMatch | undefined, weight: number) {
   if (!match) return null;
   const factor = weight / 100;
   const calc = (value: number | null | undefined) =>
     value === null || value === undefined ? null : Number(value) * factor;
 
   return {
     calories: calc(match.kcal_100g),
     protein: calc(match.protein_100g),
     carbs: calc(match.carbs_100g),
     fat: calc(match.fat_100g),
   };
 }
 
 function buildRingStyle(progress: number, isOver: boolean) {
   const clamped = Math.min(Math.max(progress, 0), 1);
   const percent = clamped * 360;
   const base = isOver ? "#ef4444" : "#10b981";
   const bg = "rgba(255,255,255,0.08)";
 
   return {
     background: `conic-gradient(${base} ${percent}deg, ${bg} 0deg)`,
   };
 }
 
+function buildDonutStyle(progress: number, color: string) {
+  const clamped = Math.min(Math.max(progress, 0), 1);
+  const percent = clamped * 360;
+  const bg = "rgba(255,255,255,0.08)";
+
+  return {
+    background: `conic-gradient(${color} ${percent}deg, ${bg} 0deg)`,
+  };
+}
+
 async function resizeImageFile(file: File) {
   const maxSize = 1024;
   const image = document.createElement("img");
   const reader = new FileReader();
 
   const dataUrl = await new Promise<string>((resolve, reject) => {
     reader.onerror = () => reject(new Error("Unable to read image"));
     reader.onload = () => resolve(reader.result as string);
     reader.readAsDataURL(file);
   });
 
   image.src = dataUrl;
 
   await new Promise((resolve, reject) => {
     image.onload = () => resolve(null);
     image.onerror = () => reject(new Error("Unable to load image for resizing"));
   });
 
   const { width, height } = image;
   const scale = Math.min(1, maxSize / Math.max(width, height));
   const targetWidth = Math.round(width * scale);
   const targetHeight = Math.round(height * scale);
 
   const canvas = document.createElement("canvas");
   canvas.width = targetWidth;
@@ -198,125 +233,194 @@ class AppErrorBoundary extends React.Component<
           <p className="mt-2 text-sm text-red-100/80">
             We hit an unexpected issue. Try refreshing or switch to manual logging while we recover.
           </p>
           <div className="mt-4 flex gap-2">
             <button className="btn bg-white/10 text-white hover:bg-white/20" type="button" onClick={() => location.reload()}>
               Refresh
             </button>
             <a className="btn" href="/login">
               Go to login
             </a>
           </div>
         </div>
       );
     }
 
     return this.props.children;
   }
 }
 
 export default function HomeClient({
   initialLogs,
   userEmail,
   selectedDate,
   profile,
   streak,
+  templates,
+  portionMemory,
+  initialRecentFoods,
 }: {
   initialLogs: FoodLogRecord[];
   userEmail: string | null | undefined;
   selectedDate: string;
   profile: UserProfile;
   streak: number;
+  templates: MealTemplate[];
+  portionMemory: PortionMemoryRow[];
+  initialRecentFoods: RecentFood[];
 }) {
   const [captureMode, setCaptureMode] = useState<"photo" | "manual">("photo");
   const [filePreview, setFilePreview] = useState<string | null>(null);
   const [imagePublicUrl, setImagePublicUrl] = useState<string | null>(null);
   const [isUploading, setIsUploading] = useState(false);
   const [isImageUploading, setIsImageUploading] = useState(false);
   const [draft, setDraft] = useState<DraftLog[]>([]);
   const [dailyLogs, setDailyLogs] = useState<FoodLogRecord[]>(initialLogs);
   const [error, setError] = useState<string | null>(null);
   const [editingWeightIndex, setEditingWeightIndex] = useState<number | null>(
     null,
   );
   const [manualOpenIndex, setManualOpenIndex] = useState<number | null>(null);
   const [manualQuery, setManualQuery] = useState("");
   const [manualResults, setManualResults] = useState<MacroMatch[]>([]);
   const [isSearching, startSearching] = useTransition();
   const [loggingIndex, setLoggingIndex] = useState<number | null>(null);
   const [isQuickSaving, setIsQuickSaving] = useState(false);
   const [quickName, setQuickName] = useState("");
   const [quickCalories, setQuickCalories] = useState<number | null>(null);
   const [quickProtein, setQuickProtein] = useState<number | null>(null);
   const [quickCarbs, setQuickCarbs] = useState<number | null>(null);
   const [quickFat, setQuickFat] = useState<number | null>(null);
   const [editingLogId, setEditingLogId] = useState<string | null>(null);
   const [editForm, setEditForm] = useState<Partial<FoodLogRecord>>({});
   const [savingProfile, setSavingProfile] = useState(false);
   const [deletingId, setDeletingId] = useState<string | null>(null);
+  const [templateList, setTemplateList] = useState<MealTemplate[]>(templates);
+  const [selectedTemplateId, setSelectedTemplateId] = useState<string | null>(templates[0]?.id ?? null);
+  const [isApplyingTemplate, setIsApplyingTemplate] = useState(false);
+  const [templateName, setTemplateName] = useState("");
+  const [isSavingTemplate, setIsSavingTemplate] = useState(false);
+  const [portionMemoryList, setPortionMemoryList] = useState<PortionMemoryRow[]>(portionMemory);
+  const [recentFoods, setRecentFoods] = useState<MacroMatch[]>(
+    initialRecentFoods.map((item) => ({
+      description: item.food_name,
+      kcal_100g: item.calories,
+      protein_100g: item.protein,
+      carbs_100g: item.carbs,
+      fat_100g: item.fat,
+    })),
+  );
+  const [isLoadingRecentFoods, setIsLoadingRecentFoods] = useState(false);
   const [profileForm, setProfileForm] = useState<ProfileFormState>({
     height: profile?.height ?? 170,
     weight: profile?.weight ?? 70,
     age: profile?.age ?? 30,
     activityLevel: (profile?.activity_level as ActivityLevel | undefined) ?? "light",
     goalType: (profile?.goal_type as GoalType | undefined) ?? "maintain",
     macroSplit: (profile?.macro_split as Record<string, number> | null) ?? {
       protein: 30,
       carbs: 40,
       fat: 30,
     },
   });
   const router = useRouter();
 
   const confidenceLabel = useMemo(() => {
     if (!draft[0]?.match) return "Pending";
     const similarity = draft[0].match.similarity ?? 0;
     if (similarity >= 0.9) return "High confidence";
     if (similarity >= 0.75) return "Medium confidence";
     return "Low confidence - please verify manually";
   }, [draft]);
 
   const dailyTotals = useMemo(() => {
     return dailyLogs.reduce(
       (acc, item) => ({
         calories: acc.calories + Number(item.calories ?? 0),
         protein: acc.protein + Number(item.protein ?? 0),
         carbs: acc.carbs + Number(item.carbs ?? 0),
         fat: acc.fat + Number(item.fat ?? 0),
       }),
       { calories: 0, protein: 0, carbs: 0, fat: 0 },
     );
   }, [dailyLogs]);
 
   const calorieTarget = profile?.daily_calorie_target ?? 2000;
   const proteinTarget = profile?.daily_protein_target ?? 120;
 
   const selectedDateObj = useMemo(
     () => buildDateFromInput(selectedDate),
     [selectedDate],
   );
 
+  const portionMemoryMap = useMemo(() => {
+    const map = new Map<string, { weight: number; count: number }>();
+    portionMemoryList.forEach((row) => {
+      const key = row.food_name.toLowerCase();
+      const existing = map.get(key);
+      if (!existing || row.count > existing.count) {
+        map.set(key, { weight: row.weight_g, count: row.count });
+      }
+    });
+    return new Map(Array.from(map.entries()).map(([key, value]) => [key, value.weight]));
+  }, [portionMemoryList]);
+
+  const macroTargets = useMemo(() => {
+    const split = profileForm.macroSplit as Record<string, number>;
+    const totalCalories = calorieTarget || 1;
+    const proteinFromSplit = ((split?.protein ?? 0) / 100) * totalCalories / 4;
+    const carbsTarget = ((split?.carbs ?? 0) / 100) * totalCalories / 4;
+    const fatTarget = ((split?.fat ?? 0) / 100) * totalCalories / 9;
+
+    return {
+      protein: proteinFromSplit > 0 ? proteinFromSplit : proteinTarget,
+      carbs: carbsTarget,
+      fat: fatTarget,
+    };
+  }, [calorieTarget, proteinTarget, profileForm.macroSplit]);
+
+  const bumpPortionMemory = (foodName: string, weight: number) => {
+    setPortionMemoryList((prev) => {
+      const existingIndex = prev.findIndex(
+        (row) =>
+          row.food_name.toLowerCase() === foodName.toLowerCase() &&
+          Math.round(row.weight_g) === Math.round(weight),
+      );
+
+      if (existingIndex !== -1) {
+        const next = [...prev];
+        next[existingIndex] = {
+          ...next[existingIndex],
+          count: next[existingIndex].count + 1,
+        };
+        return next;
+      }
+
+      return [{ food_name: foodName, weight_g: weight, count: 1 }, ...prev].slice(0, 200);
+    });
+  };
+
   const navigateToDate = (value: string) => {
     if (!value) {
       router.push("/");
       return;
     }
     router.push(`/?date=${value}`);
   };
 
   const shiftDate = (delta: number) => {
     const adjusted = new Date(selectedDateObj);
     adjusted.setDate(adjusted.getDate() + delta);
     navigateToDate(formatDateParam(adjusted));
   };
 
   const onFileChange = async (file?: File) => {
     if (!file) return;
     setCaptureMode("photo");
     setError(null);
     setIsUploading(true);
     setIsImageUploading(true);
     setImagePublicUrl(null);
     setDraft([]);
 
     let processed = file;
     try {
@@ -363,196 +467,322 @@ export default function HomeClient({
       } = supabaseBrowser.storage.from(bucket).getPublicUrl(path);
 
       if (publicUrlError) {
         throw publicUrlError;
       }
 
       return publicUrlData.publicUrl;
     })()
       .then((url) => {
         if (url) setImagePublicUrl(url);
         return url;
       })
       .catch((uploadErr) => {
         console.error(uploadErr);
         setError(
           uploadErr instanceof Error
             ? uploadErr.message
             : "Unable to upload the image to storage.",
         );
         toast.error("Image upload failed. You can still log without a photo.");
         return null;
       })
       .finally(() => setIsImageUploading(false));
 
     try {
-      const formData = new FormData();
-      formData.append("file", processed);
-
-      const response = await fetch("/api/analyze", {
-        method: "POST",
-        body: formData,
-      });
-
-      if (!response.ok) {
-        throw new Error("Unable to analyze image. Please try again.");
-      }
-
-      const payload = (await response.json()) as {
-        draft: DraftLog[];
-        imagePath?: string;
+      const analyzeWithRetry = async () => {
+        let lastError: Error | null = null;
+        for (let attempt = 1; attempt <= 3; attempt++) {
+          try {
+            const formData = new FormData();
+            formData.append("file", processed);
+
+            const response = await fetch("/api/analyze", {
+              method: "POST",
+              body: formData,
+            });
+
+            if (!response.ok) {
+              if (response.status === 413) {
+                throw new Error("Image too large. Please upload a smaller photo.");
+              }
+              if (response.status >= 500) {
+                throw new Error("AI overloaded. Retrying...");
+              }
+              throw new Error("Unable to analyze image. Please try again.");
+            }
+
+            const payload = (await response.json()) as {
+              draft: DraftLog[];
+              imagePath?: string;
+            };
+            return payload;
+          } catch (attemptError) {
+            lastError =
+              attemptError instanceof Error
+                ? attemptError
+                : new Error("Unexpected issue analyzing the image.");
+            if (attempt < 3) {
+              toast.error(lastError.message);
+              await new Promise((resolve) => setTimeout(resolve, 400 * attempt));
+              continue;
+            }
+            throw lastError;
+          }
+        }
+        throw lastError ?? new Error("Unable to analyze image.");
       };
 
-      const enhanced = payload.draft.map((item) => ({
-        ...item,
-        weight: extractWeight(item.quantity_estimate),
-      }));
+      const payload = await analyzeWithRetry();
+
+      const enhanced = payload.draft.map((item) => {
+        const fallbackWeight = extractWeight(item.quantity_estimate);
+        const memoryWeight = portionMemoryMap.get(item.food_name.toLowerCase());
+        return {
+          ...item,
+          weight: memoryWeight ?? fallbackWeight,
+        };
+      });
       setDraft(enhanced);
       if (payload.imagePath) setFilePreview(payload.imagePath);
     } catch (err) {
       console.error(err);
-      setError(
+      const message =
         err instanceof Error
           ? err.message
-          : "Unexpected issue analyzing the image.",
-      );
+          : "Unexpected issue analyzing the image.";
+      setError(message);
+      if (message.includes("too large")) {
+        toast.error("Image too large");
+      } else if (message.toLowerCase().includes("overloaded")) {
+        toast.error("AI overloaded, please retry");
+      } else if (message.toLowerCase().includes("fetch") || message.toLowerCase().includes("network")) {
+        toast.error("Database connection lost");
+      }
       setDraft([
         {
           food_name: "Manual entry",
           quantity_estimate: "100g",
           search_term: "manual search",
           weight: 100,
         },
       ]);
       setManualOpenIndex(0);
       setCaptureMode("manual");
     } finally {
       await uploadPromise;
       setIsUploading(false);
     }
   };
 
   const updateWeight = (index: number, weight: number) => {
     const safeWeight = Number.isFinite(weight) && weight > 0 ? weight : 1;
     setDraft((prev) =>
       prev.map((item, idx) => (idx === index ? { ...item, weight: safeWeight } : item)),
     );
   };
 
   const openManualSearch = (index: number) => {
     setManualOpenIndex(index);
     setManualResults([]);
     setManualQuery(draft[index]?.search_term ?? "");
+    void loadRecentFoodsList();
   };
 
   const runManualSearch = () => {
     startSearching(async () => {
       try {
         const results = await manualSearch(manualQuery);
         setManualResults(results);
       } catch (err) {
         console.error(err);
         setError(
           err instanceof Error
             ? err.message
             : "Unable to search. Please try again.",
         );
       }
     });
   };
 
   const applyManualResult = (result: MacroMatch) => {
     if (manualOpenIndex === null) return;
     setDraft((prev) =>
       prev.map((item, idx) =>
         idx === manualOpenIndex ? { ...item, match: result } : item,
       ),
     );
     setManualOpenIndex(null);
   };
 
   const handleConfirm = async (index: number) => {
     const item = draft[index];
     if (!item) return;
     setError(null);
     setLoggingIndex(index);
 
     try {
       const inserted = await logFood({
         foodName: item.food_name,
         weight: item.weight,
         match: item.match,
         imageUrl: imagePublicUrl,
       });
       setDailyLogs((prev) => [inserted as FoodLogRecord, ...prev]);
+      bumpPortionMemory(item.food_name, item.weight);
       toast.success("Food log saved");
     } catch (err) {
       console.error(err);
       setError(
         err instanceof Error ? err.message : "Unable to save your log entry.",
       );
       toast.error("Unable to save your log entry");
     } finally {
       setLoggingIndex(null);
     }
   };
 
   const handleQuickAdd = async () => {
     if (!quickName.trim() || quickCalories === null) {
       setError("Enter a name and calories to quick add.");
       return;
     }
 
     setIsQuickSaving(true);
     setError(null);
     try {
       const inserted = await logFood({
         foodName: quickName.trim(),
         weight: 1,
         manualMacros: {
           calories: quickCalories,
           protein: quickProtein ?? null,
           carbs: quickCarbs ?? null,
           fat: quickFat ?? null,
         },
       });
       setDailyLogs((prev) => [inserted as FoodLogRecord, ...prev]);
       setQuickName("");
       setQuickCalories(null);
       setQuickProtein(null);
       setQuickCarbs(null);
       setQuickFat(null);
       toast.success("Entry added");
     } catch (err) {
       console.error(err);
       setError(err instanceof Error ? err.message : "Unable to quick add.");
       toast.error("Unable to quick add");
     } finally {
       setIsQuickSaving(false);
     }
   };
 
+  const handleApplyTemplate = async () => {
+    if (!selectedTemplateId) {
+      setError("Select a template to load.");
+      return;
+    }
+    setIsApplyingTemplate(true);
+    setError(null);
+    try {
+      const inserted = await applyMealTemplate(selectedTemplateId);
+      setDailyLogs((prev) => {
+        const combined = [...(inserted as FoodLogRecord[]), ...prev];
+        return combined.sort(
+          (a, b) => new Date(b.consumed_at).getTime() - new Date(a.consumed_at).getTime(),
+        );
+      });
+      (inserted as FoodLogRecord[]).forEach((log) => bumpPortionMemory(log.food_name, log.weight_g));
+      toast.success("Template applied");
+    } catch (err) {
+      console.error(err);
+      setError(err instanceof Error ? err.message : "Unable to apply template.");
+      toast.error("Unable to apply template");
+    } finally {
+      setIsApplyingTemplate(false);
+    }
+  };
+
+  const handleSaveTemplate = async () => {
+    if (!draft.length) {
+      setError("Generate a draft first to save it as a template.");
+      return;
+    }
+    const name = templateName.trim() || `Meal ${new Date().toLocaleDateString()}`;
+    setIsSavingTemplate(true);
+    setError(null);
+    try {
+      const items: MealTemplateItem[] = draft.map((item) => {
+        const macros = adjustedMacros(item.match, item.weight) ?? {
+          calories: null,
+          protein: null,
+          carbs: null,
+          fat: null,
+        };
+        return {
+          food_name: item.food_name,
+          weight_g: item.weight,
+          calories: macros.calories,
+          protein: macros.protein,
+          carbs: macros.carbs,
+          fat: macros.fat,
+        };
+      });
+
+      const saved = await saveMealTemplate(name, items);
+      const newTemplate: MealTemplate = {
+        id: saved.id as string,
+        name: saved.name as string,
+        items: saved.items as MealTemplateItem[],
+      };
+      setTemplateList((prev) => [newTemplate, ...prev]);
+      setSelectedTemplateId(newTemplate.id);
+      setTemplateName("");
+      toast.success("Meal saved for quick loading");
+    } catch (err) {
+      console.error(err);
+      setError(err instanceof Error ? err.message : "Unable to save template.");
+      toast.error("Unable to save template");
+    } finally {
+      setIsSavingTemplate(false);
+    }
+  };
+
+  const loadRecentFoodsList = async () => {
+    if (recentFoods.length || isLoadingRecentFoods) return;
+    setIsLoadingRecentFoods(true);
+    try {
+      const recents = await getRecentFoods();
+      setRecentFoods(recents);
+    } catch (err) {
+      console.error(err);
+      toast.error("Unable to load recent foods");
+    } finally {
+      setIsLoadingRecentFoods(false);
+    }
+  };
+
   const beginEditLog = (log: FoodLogRecord) => {
     setEditingLogId(log.id);
     setEditForm({
       food_name: log.food_name,
       weight_g: log.weight_g,
       calories: log.calories,
       protein: log.protein,
       carbs: log.carbs,
       fat: log.fat,
     });
   };
 
   const saveLogEdits = async () => {
     if (!editingLogId) return;
     try {
       await updateFoodLog(editingLogId, {
         food_name: editForm.food_name,
         weight_g: editForm.weight_g,
         calories: editForm.calories ?? null,
         protein: editForm.protein ?? null,
         carbs: editForm.carbs ?? null,
         fat: editForm.fat ?? null,
       });
 
       setDailyLogs((prev) =>
@@ -766,116 +996,191 @@ export default function HomeClient({
                     <span className="capitalize">{macro}</span>
                     <input
                       className="w-full rounded-lg border border-white/10 bg-white/5 px-3 py-2 text-white focus:border-emerald-400 focus:outline-none"
                       type="number"
                       min={0}
                       max={100}
                       value={profileForm.macroSplit[macro] ?? 0}
                       onChange={(e) =>
                         setProfileForm((prev) => ({
                           ...prev,
                           macroSplit: { ...prev.macroSplit, [macro]: Number(e.target.value) },
                         }))
                       }
                     />
                   </label>
                 ))}
               </div>
             </div>
           </div>
           <button className="btn" disabled={savingProfile} onClick={saveProfile} type="button">
             {savingProfile ? "Saving..." : "Save goals"}
           </button>
         </div>
         <div className="rounded-2xl border border-white/10 bg-slate-900/50 p-4">
           <p className="text-sm uppercase tracking-wide text-emerald-200">Today</p>
-          <div className="mt-4 flex items-center gap-6">
+          <div className="mt-4 flex flex-wrap items-center gap-6">
             <div
               aria-label="Calorie progress"
               className="grid h-32 w-32 place-items-center rounded-full bg-white/5 text-center text-white"
               style={buildRingStyle(dailyTotals.calories / (calorieTarget || 1), dailyTotals.calories > calorieTarget)}
             >
               <div className="flex flex-col text-sm">
                 <span className="text-xs text-white/70">Calories</span>
                 <span className="text-lg font-semibold text-white">
                   {formatNumber(dailyTotals.calories, 0)} / {calorieTarget}
                 </span>
               </div>
             </div>
-            <div className="space-y-2 text-sm text-white/70">
-              <p>
-                Protein: <span className="text-white">{formatNumber(dailyTotals.protein)}g</span>{" "}
-                <span className="text-white/60">/ {proteinTarget}g</span>
-              </p>
-              <p>
-                Carbs: <span className="text-white">{formatNumber(dailyTotals.carbs)}g</span>
-              </p>
-              <p>
-                Fat: <span className="text-white">{formatNumber(dailyTotals.fat)}g</span>
-              </p>
-              <p className="text-emerald-200">Stay green to stay on target.</p>
+            <div className="grid flex-1 gap-3 sm:grid-cols-3">
+              {[
+                {
+                  key: "protein",
+                  label: "Protein",
+                  value: dailyTotals.protein,
+                  target: macroTargets.protein || proteinTarget,
+                  color: "#38bdf8",
+                  suffix: "g",
+                },
+                {
+                  key: "carbs",
+                  label: "Carbs",
+                  value: dailyTotals.carbs,
+                  target: macroTargets.carbs || 1,
+                  color: "#fbbf24",
+                  suffix: "g",
+                },
+                {
+                  key: "fat",
+                  label: "Fat",
+                  value: dailyTotals.fat,
+                  target: macroTargets.fat || 1,
+                  color: "#f472b6",
+                  suffix: "g",
+                },
+              ].map((macro) => (
+                <div
+                  className="flex items-center gap-3 rounded-xl border border-white/10 bg-white/5 p-3 text-sm text-white"
+                  key={macro.key}
+                >
+                  <div
+                    aria-label={`${macro.label} progress`}
+                    className="grid h-16 w-16 place-items-center rounded-full text-xs"
+                    style={buildDonutStyle(
+                      macro.value / (macro.target || 1),
+                      macro.color,
+                    )}
+                  >
+                    <div className="text-center text-[11px] leading-tight text-white">
+                      <div className="font-semibold">{formatNumber(macro.value, 0)}{macro.suffix}</div>
+                      <div className="text-white/60">/ {formatNumber(macro.target, 0)}{macro.suffix}</div>
+                    </div>
+                  </div>
+                  <div>
+                    <p className="text-xs uppercase tracking-wide text-white/60">
+                      {macro.label}
+                    </p>
+                    <p className="text-white/80">
+                      {formatNumber(macro.value, 1)} / {formatNumber(macro.target, 0)}{macro.suffix}
+                    </p>
+                  </div>
+                </div>
+              ))}
             </div>
           </div>
         </div>
       </section>
 
       <section className="grid gap-6 lg:grid-cols-[1.2fr,0.8fr]">
         <div className="card space-y-4">
           <div className="flex items-center justify-between">
             <div>
               <p className="text-sm uppercase tracking-wide text-emerald-200">
                 Capture
               </p>
               <h2 className="text-xl font-semibold text-white">
                 Upload a meal photo or quick add
               </h2>
               <p className="text-sm text-white/60">
                 We immediately render the image while the backend runs Gemini +
                 Supabase searches in parallel, or you can bypass AI with manual
                 text entry.
               </p>
             </div>
             <div className="rounded-full border border-white/10 bg-white/5 text-sm text-white">
               <button
                 className={`rounded-full px-3 py-1 ${captureMode === "photo" ? "bg-emerald-500 text-white" : ""}`}
                 onClick={() => setCaptureMode("photo")}
                 type="button"
               >
                 Photo
               </button>
               <button
                 className={`rounded-full px-3 py-1 ${captureMode === "manual" ? "bg-emerald-500 text-white" : ""}`}
                 onClick={() => setCaptureMode("manual")}
                 type="button"
               >
                 Text / Manual
               </button>
             </div>
           </div>
 
           {captureMode === "photo" ? (
             <>
+              <div className="rounded-xl border border-white/10 bg-slate-900/60 p-4">
+                <div className="flex flex-wrap items-center justify-between gap-2">
+                  <div>
+                    <p className="text-sm uppercase tracking-wide text-emerald-200">Quick load</p>
+                    <p className="text-xs text-white/60">Drop in a saved meal template to insert multiple entries.</p>
+                  </div>
+                  <span className="pill bg-white/10 text-white/60">
+                    {templateList.length} saved
+                  </span>
+                </div>
+                <div className="mt-3 flex flex-wrap items-center gap-3">
+                  <select
+                    className="min-w-[200px] rounded-lg border border-white/10 bg-white/5 px-3 py-2 text-white focus:border-emerald-400 focus:outline-none"
+                    value={selectedTemplateId ?? ""}
+                    onChange={(e) => setSelectedTemplateId(e.target.value || null)}
+                  >
+                    {templateList.length === 0 && <option value="">No templates yet</option>}
+                    {templateList.map((template) => (
+                      <option key={template.id} value={template.id}>
+                        {template.name}
+                      </option>
+                    ))}
+                  </select>
+                  <button
+                    className="btn"
+                    disabled={!selectedTemplateId || isApplyingTemplate}
+                    onClick={handleApplyTemplate}
+                    type="button"
+                  >
+                    {isApplyingTemplate ? "Loading..." : "Quick load meal"}
+                  </button>
+                </div>
+              </div>
               <label className="btn cursor-pointer">
                 <input
                   accept="image/*"
                   className="hidden"
                   type="file"
                   onChange={(event) => onFileChange(event.target.files?.[0])}
                 />
                 {isUploading ? "Scanning..." : "Take Photo"}
               </label>
               <div className="relative overflow-hidden rounded-2xl border border-white/10 bg-slate-900/40">
                 {filePreview ? (
                   <Image
                     alt="Uploaded meal preview"
                     className="h-80 w-full object-cover"
                     height={320}
                     src={filePreview}
                     width={640}
                   />
                 ) : (
                   <div className="flex h-80 items-center justify-center text-white/40">
                     Upload a photo to start the Visual RAG flow.
                   </div>
                 )}
                 {isUploading && (
                   <div className="absolute inset-0 flex items-center justify-center bg-slate-950/70 backdrop-blur-sm">
@@ -956,50 +1261,77 @@ export default function HomeClient({
             <div className="rounded-xl border border-red-500/30 bg-red-500/10 p-3 text-sm text-red-100">
               {error}
             </div>
           )}
         </div>
 
         <div className="card space-y-4">
           <div className="flex items-center justify-between">
             <div>
               <p className="text-sm uppercase tracking-wide text-emerald-200">
                 Verification
               </p>
               <h2 className="text-xl font-semibold text-white">
                 Draft entries
               </h2>
               <p className="text-sm text-white/60">
                 We never auto-save. Confirm or adjust the AI guess before
                 logging.
               </p>
             </div>
             <span className="pill bg-emerald-500/20 text-emerald-100">
               {confidenceLabel}
             </span>
           </div>
 
+          {draft.length > 0 && (
+            <div className="rounded-xl border border-white/10 bg-slate-900/60 p-4 text-sm text-white/80">
+              <div className="flex flex-wrap items-center justify-between gap-2">
+                <p className="font-medium text-white">Save as meal template</p>
+                <span className="text-xs text-white/60">
+                  Store this draft for faster future logging.
+                </span>
+              </div>
+              <div className="mt-3 flex flex-wrap items-center gap-2">
+                <input
+                  className="min-w-[200px] flex-1 rounded-lg border border-white/10 bg-white/5 px-3 py-2 text-white focus:border-emerald-400 focus:outline-none"
+                  placeholder="e.g., Chicken and Rice"
+                  value={templateName}
+                  onChange={(e) => setTemplateName(e.target.value)}
+                />
+                <button
+                  className="btn"
+                  disabled={isSavingTemplate}
+                  onClick={handleSaveTemplate}
+                  type="button"
+                >
+                  {isSavingTemplate ? "Saving..." : "Save as meal"}
+                </button>
+              </div>
+            </div>
+          )}
+
           {!draft.length ? (
             <div className="rounded-xl border border-dashed border-white/10 bg-slate-900/50 p-4 text-sm text-white/60">
               No draft yet. Upload an image to generate a structured suggestion.
             </div>
           ) : (
             <div className="space-y-3">
               {draft.map((item, index) => {
                 const adjusted = adjustedMacros(item.match, item.weight);
                 return (
                   <div
                     className="rounded-xl border border-white/10 bg-slate-900/60 p-4"
                     key={`${item.food_name}-${index}`}
                   >
                     <div className="flex flex-col gap-1">
                       <div className="flex flex-wrap items-center justify-between gap-2">
                         <h3 className="text-lg font-semibold text-white">
                           {item.food_name}
                         </h3>
                         <button
                           className="pill bg-white/10 text-white/70 hover:bg-white/20"
                           onClick={() =>
                             setEditingWeightIndex(
                               editingWeightIndex === index ? null : index,
                             )
                           }
@@ -1348,59 +1680,83 @@ export default function HomeClient({
               </button>
             </div>
             <div className="mt-4 space-y-3">
               <input
                 autoFocus
                 className="w-full rounded-lg border border-white/10 bg-white/5 px-3 py-2 text-white focus:border-emerald-400 focus:outline-none"
                 placeholder="Search for a food (e.g., grilled chicken)"
                 type="text"
                 value={manualQuery}
                 onChange={(e) => setManualQuery(e.target.value)}
               />
               <div className="flex items-center gap-2">
                 <button
                   className="btn"
                   disabled={isSearching}
                   onClick={runManualSearch}
                   type="button"
                 >
                   {isSearching ? "Searching..." : "Search"}
                 </button>
                 <p className="text-xs text-white/60">
                   Uses the same embedding model + match_foods RPC as the AI path.
                 </p>
               </div>
               <div className="max-h-64 space-y-2 overflow-y-auto">
-                {!manualResults.length ? (
-                  <p className="text-sm text-white/60">
-                    No results yet. Enter a query to search.
-                  </p>
-                ) : (
+                {!manualResults.length && !manualQuery && recentFoods.length ? (
+                  <div className="space-y-2">
+                    <p className="text-xs uppercase tracking-wide text-white/50">
+                      Recent picks
+                    </p>
+                    {recentFoods.map((result, idx) => (
+                      <button
+                        className="w-full rounded-xl border border-white/10 bg-white/5 p-3 text-left hover:border-emerald-400/70"
+                        key={`${result.description}-recent-${idx}`}
+                        onClick={() => applyManualResult(result)}
+                        type="button"
+                      >
+                        <p className="text-white">{result.description}</p>
+                        <p className="text-sm text-white/70">
+                          Kcal {formatNumber(result.kcal_100g)}  Protein{" "}
+                          {formatNumber(result.protein_100g)}g  Carbs{" "}
+                          {formatNumber(result.carbs_100g)}g  Fat{" "}
+                          {formatNumber(result.fat_100g)}g
+                        </p>
+                      </button>
+                    ))}
+                  </div>
+                ) : null}
+
+                {manualResults.length ? (
                   manualResults.map((result, idx) => (
                     <button
                       className="w-full rounded-xl border border-white/10 bg-white/5 p-3 text-left hover:border-emerald-400/70"
                       key={`${result.description}-${idx}`}
                       onClick={() => applyManualResult(result)}
                       type="button"
                     >
                       <p className="text-white">{result.description}</p>
                       <p className="text-xs text-white/60">
                         Similarity {formatNumber(result.similarity, 2)}
                       </p>
                       <p className="text-sm text-white/70">
                         Kcal {formatNumber(result.kcal_100g)}  Protein{" "}
                         {formatNumber(result.protein_100g)}g  Carbs{" "}
                         {formatNumber(result.carbs_100g)}g  Fat{" "}
                         {formatNumber(result.fat_100g)}g
                       </p>
                     </button>
                   ))
-                )}
+                ) : manualQuery || !recentFoods.length ? (
+                  <p className="text-sm text-white/60">
+                    {isLoadingRecentFoods ? "Loading recent foods..." : "No results yet. Enter a query to search."}
+                  </p>
+                ) : null}
               </div>
             </div>
           </div>
         </div>
       )}
       </main>
     </AppErrorBoundary>
   );
 }
diff --git a/src/app/page.tsx b/src/app/page.tsx
index 1cb702b2034fc739986d51b7adc29ad2ed794e8a..ab5d6ed5bc9977a6b0763d9f000907b3dbd1bdb2 100644
--- a/src/app/page.tsx
+++ b/src/app/page.tsx
@@ -1,41 +1,53 @@
 import { redirect } from "next/navigation";
 import HomeClient from "./home-client";
 import { createSupabaseServerClient } from "@/lib/supabase";
 
 type UserProfile = {
   user_id: string;
   height: number | null;
   weight: number | null;
   age: number | null;
   activity_level: string | null;
   goal_type: string | null;
   macro_split: Record<string, unknown> | null;
   daily_calorie_target: number | null;
   daily_protein_target: number | null;
 };
 
+type MealTemplate = {
+  id: string;
+  name: string;
+  items: unknown;
+};
+
+type PortionMemoryRow = {
+  food_name: string;
+  weight_g: number;
+  count: number;
+};
+
 function parseDateParam(dateValue?: string | string[]) {
   if (!dateValue || Array.isArray(dateValue)) return new Date();
 
   const [year, month, day] = dateValue.split("-").map(Number);
 
   if (
     Number.isNaN(year) ||
     Number.isNaN(month) ||
     Number.isNaN(day) ||
     month < 1 ||
     month > 12 ||
     day < 1 ||
     day > 31
   ) {
     return new Date();
   }
 
   return new Date(year, month - 1, day);
 }
 
 function formatDateParam(date: Date) {
   return `${date.getFullYear()}-${`${date.getMonth() + 1}`.padStart(2, "0")}-${`${date.getDate()}`.padStart(2, "0")}`;
 }
 
 function calculateStreak(logDates: string[]) {
@@ -98,35 +110,60 @@ export default async function HomePage({
     .gte("consumed_at", dayStart.toISOString())
     .lt("consumed_at", nextDay.toISOString())
     .order("consumed_at", { ascending: false });
 
   if (error) {
     console.warn("Unable to load daily logs", error);
   }
 
   const { data: profile } = await supabase
     .from("user_profiles")
     .select("*")
     .eq("user_id", session.user.id)
     .maybeSingle();
 
   const { data: streakLogs } = await supabase
     .from("food_logs")
     .select("consumed_at")
     .eq("user_id", session.user.id)
     .order("consumed_at", { ascending: false })
     .limit(60);
 
   const streak = streakLogs
     ? calculateStreak(streakLogs.map((row) => row.consumed_at as string))
     : 0;
 
+  const { data: templates } = await supabase
+    .from("meal_templates")
+    .select("id, name, items")
+    .eq("user_id", session.user.id)
+    .order("created_at", { ascending: false })
+    .limit(20);
+
+  const { data: portionMemory } = await supabase
+    .from("food_logs")
+    .select("food_name, weight_g, count:count(*)")
+    .eq("user_id", session.user.id)
+    .group("food_name, weight_g")
+    .order("count", { ascending: false })
+    .limit(100);
+
+  const { data: recentFoods } = await supabase
+    .from("food_logs")
+    .select("food_name, calories, protein, carbs, fat, weight_g, consumed_at")
+    .eq("user_id", session.user.id)
+    .order("consumed_at", { ascending: false })
+    .limit(40);
+
   return (
     <HomeClient
       initialLogs={logs ?? []}
       userEmail={session.user.email ?? null}
       selectedDate={formatDateParam(dayStart)}
       profile={profile as UserProfile | null}
       streak={streak}
+      templates={(templates as MealTemplate[] | null) ?? []}
+      portionMemory={(portionMemory as PortionMemoryRow[] | null) ?? []}
+      initialRecentFoods={recentFoods ?? []}
     />
   );
 }
diff --git a/src/app/stats/page.tsx b/src/app/stats/page.tsx
index 516b1c5ecbf35c38b101fa3cc621568568b886c4..8cddf5654794fe033fc1671f2b3817b254c99c7d 100644
--- a/src/app/stats/page.tsx
+++ b/src/app/stats/page.tsx
@@ -1,58 +1,84 @@
 import { redirect } from "next/navigation";
 import StatsClient from "./stats-client";
+import WeightLogger from "../WeightLogger";
 import { createSupabaseServerClient } from "@/lib/supabase";
 
 function formatLabel(date: Date) {
   return date.toLocaleDateString(undefined, { weekday: "short" });
 }
 
 export default async function StatsPage() {
   const supabase = createSupabaseServerClient();
   const {
     data: { session },
   } = await supabase.auth.getSession();
 
   if (!session) {
     redirect("/login");
   }
 
   const end = new Date();
   end.setHours(23, 59, 59, 999);
   const start = new Date(end);
   start.setDate(end.getDate() - 6);
 
   const { data: logs } = await supabase
     .from("food_logs")
     .select("calories, consumed_at")
     .eq("user_id", session.user.id)
     .gte("consumed_at", start.toISOString())
     .lte("consumed_at", end.toISOString());
 
   const { data: profile } = await supabase
     .from("user_profiles")
     .select("daily_calorie_target")
     .eq("user_id", session.user.id)
     .maybeSingle();
 
   const calorieTarget = profile?.daily_calorie_target ?? 2000;
 
   const days: { [key: string]: number } = {};
   const cursor = new Date(start);
   for (let i = 0; i < 7; i++) {
     const key = cursor.toISOString().slice(0, 10);
     days[key] = 0;
     cursor.setDate(cursor.getDate() + 1);
   }
 
   logs?.forEach((log) => {
     const key = (log.consumed_at as string).slice(0, 10);
     days[key] = (days[key] ?? 0) + Number(log.calories ?? 0);
   });
 
+  const { data: weightLogs } = await supabase
+    .from("weight_logs")
+    .select("weight_kg, logged_at")
+    .eq("user_id", session.user.id)
+    .gte("logged_at", start.toISOString())
+    .lte("logged_at", end.toISOString())
+    .order("logged_at", { ascending: true });
+
+  const weightByDay: Record<string, number> = {};
+  weightLogs?.forEach((row) => {
+    const key = (row.logged_at as string).slice(0, 10);
+    weightByDay[key] = Number(row.weight_kg);
+  });
+
   const chartData = Object.entries(days).map(([date, calories]) => ({
     label: formatLabel(new Date(date)),
     calories,
+    weight: weightByDay[date] ?? null,
   }));
 
-  return <StatsClient data={chartData} target={calorieTarget} />;
+  const latestWeight =
+    weightLogs && weightLogs.length
+      ? Number(weightLogs[weightLogs.length - 1].weight_kg)
+      : null;
+
+  return (
+    <div className="space-y-4">
+      <StatsClient data={chartData} target={calorieTarget} />
+      <WeightLogger defaultWeight={latestWeight} />
+    </div>
+  );
 }
diff --git a/src/app/stats/stats-client.tsx b/src/app/stats/stats-client.tsx
index f553ed2fa1bdc1667ca729ed3d885208cc4e8b2e..e72169832744c033bc228c59ada9fa866a1d1da8 100644
--- a/src/app/stats/stats-client.tsx
+++ b/src/app/stats/stats-client.tsx
@@ -1,57 +1,68 @@
 "use client";
 
 import Link from "next/link";
 import {
   Bar,
-  BarChart,
+  ComposedChart,
   CartesianGrid,
   Legend,
   ResponsiveContainer,
   Tooltip,
   XAxis,
   YAxis,
+  Line,
 } from "recharts";
 
 export default function StatsClient({
   data,
   target,
 }: {
-  data: { label: string; calories: number }[];
+  data: { label: string; calories: number; weight: number | null }[];
   target: number;
 }) {
   const chartData = data.map((row) => ({
     ...row,
     goal: target,
   }));
 
   return (
     <div className="card space-y-4">
       <div className="flex items-center justify-between">
         <div>
           <p className="text-sm uppercase tracking-wide text-emerald-200">
             Weekly trends
           </p>
           <h1 className="text-2xl font-semibold text-white">Calories vs. goal</h1>
         </div>
         <Link className="btn bg-white/10 text-white hover:bg-white/20" href="/">
           Back to tracker
         </Link>
       </div>
       <div className="h-80 w-full">
         <ResponsiveContainer width="100%" height="100%">
-          <BarChart data={chartData}>
+          <ComposedChart data={chartData}>
             <CartesianGrid strokeDasharray="3 3" stroke="#1f2937" />
             <XAxis dataKey="label" stroke="#9ca3af" />
-            <YAxis stroke="#9ca3af" />
+            <YAxis stroke="#9ca3af" yAxisId="calories" />
+            <YAxis stroke="#fbbf24" yAxisId="weight" orientation="right" allowDecimals={false} />
             <Tooltip
               contentStyle={{ backgroundColor: "#0f172a", color: "white", border: "1px solid #1f2937" }}
             />
             <Legend />
-            <Bar dataKey="calories" fill="#34d399" name="Calories" />
-            <Bar dataKey="goal" fill="#2563eb" name="Goal" />
-          </BarChart>
+            <Bar dataKey="calories" fill="#34d399" name="Calories" yAxisId="calories" />
+            <Bar dataKey="goal" fill="#2563eb" name="Goal" yAxisId="calories" />
+            <Line
+              type="monotone"
+              dataKey="weight"
+              name="Weight (kg)"
+              stroke="#fbbf24"
+              strokeWidth={2}
+              yAxisId="weight"
+              dot={{ stroke: "#fbbf24", fill: "#0f172a" }}
+            />
+          </ComposedChart>
         </ResponsiveContainer>
       </div>
     </div>
   );
 }
diff --git a/supabase/migrations/01_security.sql b/supabase/migrations/01_security.sql
new file mode 100644
index 0000000000000000000000000000000000000000..84f1f0f714f966c754525ab99259535d6a166012
--- /dev/null
+++ b/supabase/migrations/01_security.sql
@@ -0,0 +1,98 @@
+-- Enable required extensions
+create extension if not exists "pgcrypto";
+
+-- Weight history table for longitudinal tracking
+create table if not exists public.weight_logs (
+  id uuid primary key default gen_random_uuid(),
+  user_id uuid references auth.users(id) on delete cascade not null,
+  weight_kg numeric not null,
+  logged_at timestamptz not null default now()
+);
+
+-- Meal templates to speed up repeat logging
+create table if not exists public.meal_templates (
+  id uuid primary key default gen_random_uuid(),
+  user_id uuid references auth.users(id) on delete cascade not null,
+  name text not null,
+  items jsonb not null,
+  created_at timestamptz not null default now()
+);
+
+-- Existing tables: ensure user_profiles is writeable only by owner
+alter table if exists public.user_profiles enable row level security;
+drop policy if exists "Users can select their profile" on public.user_profiles;
+drop policy if exists "Users can insert their profile" on public.user_profiles;
+drop policy if exists "Users can update their profile" on public.user_profiles;
+
+create policy "Users can select their profile"
+  on public.user_profiles for select
+  using (auth.uid() = user_id);
+
+create policy "Users can insert their profile"
+  on public.user_profiles for insert
+  with check (auth.uid() = user_id);
+
+create policy "Users can update their profile"
+  on public.user_profiles for update
+  using (auth.uid() = user_id)
+  with check (auth.uid() = user_id);
+
+-- Food logs should already be RLS protected; enforce owner access
+alter table if exists public.food_logs enable row level security;
+drop policy if exists "Users can select their food logs" on public.food_logs;
+drop policy if exists "Users can insert their food logs" on public.food_logs;
+drop policy if exists "Users can update their food logs" on public.food_logs;
+drop policy if exists "Users can delete their food logs" on public.food_logs;
+
+create policy "Users can select their food logs"
+  on public.food_logs for select
+  using (auth.uid() = user_id);
+
+create policy "Users can insert their food logs"
+  on public.food_logs for insert
+  with check (auth.uid() = user_id);
+
+create policy "Users can update their food logs"
+  on public.food_logs for update
+  using (auth.uid() = user_id)
+  with check (auth.uid() = user_id);
+
+create policy "Users can delete their food logs"
+  on public.food_logs for delete
+  using (auth.uid() = user_id);
+
+-- Weight log policies
+alter table public.weight_logs enable row level security;
+drop policy if exists "Users can select their weight logs" on public.weight_logs;
+drop policy if exists "Users can insert their weight logs" on public.weight_logs;
+
+create policy "Users can select their weight logs"
+  on public.weight_logs for select
+  using (auth.uid() = user_id);
+
+create policy "Users can insert their weight logs"
+  on public.weight_logs for insert
+  with check (auth.uid() = user_id);
+
+-- Meal template policies
+alter table public.meal_templates enable row level security;
+drop policy if exists "Users can select their meal templates" on public.meal_templates;
+drop policy if exists "Users can insert their meal templates" on public.meal_templates;
+drop policy if exists "Users can delete their meal templates" on public.meal_templates;
+
+create policy "Users can select their meal templates"
+  on public.meal_templates for select
+  using (auth.uid() = user_id);
+
+create policy "Users can insert their meal templates"
+  on public.meal_templates for insert
+  with check (auth.uid() = user_id);
+
+create policy "Users can delete their meal templates"
+  on public.meal_templates for delete
+  using (auth.uid() = user_id);
+
+-- USDA reference data should remain read-only to anon/authenticated roles
+revoke insert, update, delete on public.usda_library from anon, authenticated;
+grant select on public.usda_library to anon, authenticated;
+grant insert, update, delete on public.usda_library to service_role;
